// ==================== PROJECT STRUCTURE ====================
/*
project-root/
├── src/
│   ├── config/
│   │   ├── database.js
│   │   ├── env.js
│   │   └── security.js
│   ├── middleware/
│   │   ├── auth.middleware.js
│   │   ├── error.middleware.js
│   │   ├── rateLimit.middleware.js
│   │   ├── validation.middleware.js
│   │   └── logger.middleware.js
│   ├── utils/
│   │   ├── ApiResponse.js
│   │   ├── ApiError.js
│   │   ├── asyncHandler.js
│   │   ├── logger.js
│   │   └── cache.js
│   ├── services/
│   │   └── user.service.js
│   ├── controllers/
│   │   └── user.controller.js
│   ├── routes/
│   │   ├── index.js
│   │   └── user.routes.js
│   ├── models/
│   │   └── user.model.js
│   └── app.js
├── .env.example
├── package.json
└── server.js
*/

// ==================== package.json ====================
{
  "name": "scalable-nodejs-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest --coverage"
  },
  "dependencies": {
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "cors": "^2.8.5",
    "compression": "^1.7.4",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "mysql2": "^3.7.0",
    "sequelize": "^6.35.2",
    "redis": "^4.6.12",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "winston": "^3.11.0",
    "dotenv": "^16.3.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "uuid": "^9.0.1"
  }
}

// ==================== .env.example ====================
/*
NODE_ENV=production
PORT=3000
DB_HOST=localhost
DB_PORT=3306
DB_NAME=yourdb
DB_USER=root
DB_PASSWORD=your-password
DB_POOL_MAX=10
DB_POOL_MIN=2
DB_POOL_ACQUIRE=30000
DB_POOL_IDLE=10000
REDIS_URL=redis://localhost:6379
JWT_SECRET=your-super-secret-jwt-key-change-this
JWT_EXPIRE=7d
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
LOG_LEVEL=info
BASE_URL=http://localhost:3000
UPLOAD_DIR=uploads
MAX_FILE_SIZE=10485760
*/

// ==================== src/config/security.js ====================
const helmet = require('helmet');
const config = require('./env');

class SecurityConfig {
  // Helmet configuration for HTTP headers security
  getHelmetConfig() {
    return {
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          connectSrc: ["'self'"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
      crossOriginEmbedderPolicy: true,
      crossOriginOpenerPolicy: true,
      crossOriginResourcePolicy: { policy: 'cross-origin' },
      dnsPrefetchControl: { allow: false },
      frameguard: { action: 'deny' },
      hidePoweredBy: true,
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true,
      },
      ieNoOpen: true,
      noSniff: true,
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
      xssFilter: true,
    };
  }

  // CORS configuration
  getCorsConfig() {
    const whitelist = process.env.CORS_ORIGIN 
      ? process.env.CORS_ORIGIN.split(',') 
      : ['http://localhost:3000', 'http://localhost:3001'];

    return {
      origin: (origin, callback) => {
        // Allow requests with no origin (mobile apps, Postman, etc.)
        if (!origin || whitelist.indexOf(origin) !== -1) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
      optionsSuccessStatus: 200,
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
      allowedHeaders: [
        'Content-Type',
        'Authorization',
        'X-Requested-With',
        'Accept',
        'Origin',
      ],
      exposedHeaders: ['Content-Range', 'X-Content-Range'],
      maxAge: 600, // 10 minutes
    };
  }

  // Password validation rules
  validatePasswordStrength(password) {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    const errors = [];

    if (password.length < minLength) {
      errors.push(`Password must be at least ${minLength} characters long`);
    }
    if (!hasUpperCase) {
      errors.push('Password must contain at least one uppercase letter');
    }
    if (!hasLowerCase) {
      errors.push('Password must contain at least one lowercase letter');
    }
    if (!hasNumbers) {
      errors.push('Password must contain at least one number');
    }
    if (!hasSpecialChar) {
      errors.push('Password must contain at least one special character');
    }

    return {
      isValid: errors.length === 0,
      errors,
      strength: this.calculatePasswordStrength(password),
    };
  }

  // Calculate password strength score (0-100)
  calculatePasswordStrength(password) {
    let strength = 0;

    if (password.length >= 8) strength += 20;
    if (password.length >= 12) strength += 10;
    if (password.length >= 16) strength += 10;
    if (/[a-z]/.test(password)) strength += 15;
    if (/[A-Z]/.test(password)) strength += 15;
    if (/\d/.test(password)) strength += 15;
    if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength += 15;

    return Math.min(strength, 100);
  }

  // Sanitize user input to prevent XSS
  sanitizeInput(input) {
    if (typeof input !== 'string') return input;

    return input
      .replace(/[<>]/g, '') // Remove < and >
      .trim();
  }

  // Validate email format
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // Generate secure random token
  generateSecureToken(length = 32) {
    const crypto = require('crypto');
    return crypto.randomBytes(length).toString('hex');
  }

  // Hash sensitive data (for logging purposes)
  hashSensitiveData(data) {
    const crypto = require('crypto');
    return crypto
      .createHash('sha256')
      .update(data.toString())
      .digest('hex')
      .substring(0, 16);
  }

  // IP address validation
  isValidIP(ip) {
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
    return ipv4Regex.test(ip) || ipv6Regex.test(ip);
  }

  // SQL injection prevention - escape special characters
  escapeSqlInput(input) {
    if (typeof input !== 'string') return input;
    
    return input
      .replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, (char) => {
        switch (char) {
          case '\0': return '\\0';
          case '\x08': return '\\b';
          case '\x09': return '\\t';
          case '\x1a': return '\\z';
          case '\n': return '\\n';
          case '\r': return '\\r';
          case '"':
          case "'":
          case '\\':
          case '%':
            return '\\' + char;
          default:
            return char;
        }
      });
  }

  // Check for common attack patterns
  containsMaliciousPattern(input) {
    if (typeof input !== 'string') return false;

    const maliciousPatterns = [
      /<script[^>]*>.*?<\/script>/gi, // Script tags
      /javascript:/gi, // JavaScript protocol
      /on\w+\s*=/gi, // Event handlers
      /(union|select|insert|update|delete|drop|create|alter|exec|execute)/gi, // SQL keywords
      /\.\.\//, // Directory traversal
      /%00/, // Null byte
    ];

    return maliciousPatterns.some(pattern => pattern.test(input));
  }

  // Rate limiting configuration by endpoint type
  getRateLimitConfig(type = 'default') {
    const configs = {
      default: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100,
        message: 'Too many requests, please try again later',
      },
      auth: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 5, // Strict limit for auth endpoints
        message: 'Too many login attempts, please try again later',
      },
      api: {
        windowMs: 1 * 60 * 1000, // 1 minute
        max: 60,
        message: 'API rate limit exceeded',
      },
      strict: {
        windowMs: 60 * 60 * 1000, // 1 hour
        max: 10,
        message: 'Action limit exceeded, please try again later',
      },
    };

    return configs[type] || configs.default;
  }

  // Security headers middleware configuration
  getSecurityHeaders() {
    return (req, res, next) => {
      // Prevent clickjacking
      res.setHeader('X-Frame-Options', 'DENY');
      
      // Prevent MIME type sniffing
      res.setHeader('X-Content-Type-Options', 'nosniff');
      
      // Enable XSS protection
      res.setHeader('X-XSS-Protection', '1; mode=block');
      
      // Referrer policy
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
      
      // Permissions policy
      res.setHeader(
        'Permissions-Policy',
        'geolocation=(), microphone=(), camera=()'
      );
      
      // Remove server information
      res.removeHeader('X-Powered-By');
      
      next();
    };
  }

  // API key validation (for external API integrations)
  validateApiKey(apiKey) {
    const validApiKeys = process.env.API_KEYS 
      ? process.env.API_KEYS.split(',') 
      : [];
    
    return validApiKeys.includes(apiKey);
  }

  // Generate API key
  generateApiKey() {
    const crypto = require('crypto');
    const prefix = 'sk_';
    const randomPart = crypto.randomBytes(24).toString('base64').replace(/[^a-zA-Z0-9]/g, '');
    return `${prefix}${randomPart}`;
  }
}

module.exports = new SecurityConfig();

// ==================== src/config/env.js ====================
require('dotenv').config();

const config = {
  env: process.env.NODE_ENV || 'development',
  port: parseInt(process.env.PORT, 10) || 3000,
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT, 10) || 3306,
    name: process.env.DB_NAME || 'appdb',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    pool: {
      max: parseInt(process.env.DB_POOL_MAX, 10) || 10,
      min: parseInt(process.env.DB_POOL_MIN, 10) || 2,
      acquire: parseInt(process.env.DB_POOL_ACQUIRE, 10) || 30000,
      idle: parseInt(process.env.DB_POOL_IDLE, 10) || 10000,
    }
  },
  redis: {
    url: process.env.REDIS_URL || 'redis://localhost:6379',
    maxRetriesPerRequest: 3,
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'fallback-secret-change-in-production',
    expire: process.env.JWT_EXPIRE || '7d',
  },
  rateLimit: {
    windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS, 10) || 15 * 60 * 1000,
    max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS, 10) || 100,
  },
  log: {
    level: process.env.LOG_LEVEL || 'info',
  },
  upload: {
    dir: process.env.UPLOAD_DIR || 'uploads',
    maxFileSize: parseInt(process.env.MAX_FILE_SIZE, 10) || 10 * 1024 * 1024, // 10MB
  },
  baseUrl: process.env.BASE_URL || 'http://localhost:3000',
};

module.exports = config;

// ==================== src/utils/fileUpload.js ====================
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const config = require('../config/env');
const logger = require('./logger');
const ApiError = require('./ApiError');

class FileUploadManager {
    constructor() {
        this.uploadDir = path.join(process.cwd(), config.upload.dir);
        this.invoicesDir = path.join(this.uploadDir, 'invoices');
        this.ensureDirectories();
    }

    ensureDirectories() {
        // Create upload directories if they don't exist
        [this.uploadDir, this.invoicesDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                logger.info(`Created directory: ${dir}`);
            }
        });
    }

    validateBase64(base64String) {
        if (!base64String || typeof base64String !== 'string') {
            throw ApiError.badRequest('Invalid base64 string');
        }

        // Check if it's a valid base64 string
        const base64Pattern = /^data:application\/pdf;base64,/;
        if (!base64Pattern.test(base64String)) {
            throw ApiError.badRequest('File must be a PDF in base64 format');
        }

        return true;
    }

    async saveBase64PDF(base64String, type = 'invoice') {
        try {
            this.validateBase64(base64String);

            // Extract base64 data (remove data:application/pdf;base64, prefix)
            const base64Data = base64String.replace(/^data:application\/pdf;base64,/, '');
            
            // Convert base64 to buffer
            const buffer = Buffer.from(base64Data, 'base64');

            // Check file size
            if (buffer.length > config.upload.maxFileSize) {
                throw ApiError.badRequest(
                    `File size exceeds maximum allowed size of ${config.upload.maxFileSize / 1024 / 1024}MB`
                );
            }

            // Generate unique filename
            const filename = `${type}_${uuidv4()}_${Date.now()}.pdf`;
            const filepath = path.join(this.invoicesDir, filename);

            // Save file
            await fs.promises.writeFile(filepath, buffer);
            
            logger.info(`File saved: ${filename}`);

            // Generate URL
            const fileUrl = `${config.baseUrl}/uploads/invoices/${filename}`;

            return {
                filename,
                filepath,
                url: fileUrl,
                size: buffer.length,
            };
        } catch (error) {
            logger.error('Error saving PDF:', error);
            throw error instanceof ApiError ? error : ApiError.internal('Failed to save PDF');
        }
    }

    async deleteFile(filepath) {
        try {
            if (fs.existsSync(filepath)) {
                await fs.promises.unlink(filepath);
                logger.info(`File deleted: ${filepath}`);
                return true;
            }
            return false;
        } catch (error) {
            logger.error('Error deleting file:', error);
            return false;
        }
    }

    async deleteFileByUrl(url) {
        try {
            // Extract filename from URL
            const filename = url.split('/').pop();
            const filepath = path.join(this.invoicesDir, filename);
            return await this.deleteFile(filepath);
        } catch (error) {
            logger.error('Error deleting file by URL:', error);
            return false;
        }
    }

    getFileInfo(filepath) {
        try {
            const stats = fs.statSync(filepath);
            return {
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                exists: true,
            };
        } catch (error) {
            return {
                exists: false,
            };
        }
    }
}

module.exports = new FileUploadManager();

// ==================== src/config/database.js ====================
const { Sequelize } = require('sequelize');
const config = require('./env');
const logger = require('../utils/logger');

class Database {
  constructor() {
    this.sequelize = null;
    this.models = {};
  }

  async connect() {
    try {
      this.sequelize = new Sequelize(
        config.database.name,
        config.database.user,
        config.database.password,
        {
          host: config.database.host,
          port: config.database.port,
          dialect: 'mysql',
          logging: (msg) => logger.debug(msg),
          pool: {
            max: config.database.pool.max,
            min: config.database.pool.min,
            acquire: config.database.pool.acquire,
            idle: config.database.pool.idle,
          },
          define: {
            timestamps: true,
            underscored: true,
            freezeTableName: true,
          },
          dialectOptions: {
            charset: 'utf8mb4',
            connectTimeout: 60000,
          },
        }
      );

      await this.sequelize.authenticate();
      
      logger.info('MySQL connected successfully', {
        host: config.database.host,
        database: config.database.name,
      });

      // Initialize models
      this.initializeModels();

      // Sync database (use with caution in production)
      if (config.env === 'development') {
        await this.sequelize.sync({ alter: true });
        logger.info('Database synchronized');
      }

      process.on('SIGINT', async () => {
        await this.disconnect();
        process.exit(0);
      });

    } catch (error) {
      logger.error('MySQL connection failed:', error);
      process.exit(1);
    }
  }

  initializeModels() {
    // Import and initialize models here
    const User = require('../models/user.model');
    const Invoice = require('../models/invoice.model');
    
    this.models.User = User.initModel(this.sequelize);
    this.models.Invoice = Invoice.initModel(this.sequelize);
    
    logger.info('Models initialized successfully');
  }

  async disconnect() {
    if (this.sequelize) {
      await this.sequelize.close();
      logger.info('MySQL disconnected gracefully');
    }
  }

  getSequelize() {
    return this.sequelize;
  }

  getModels() {
    return this.models;
  }
}

module.exports = new Database();

// ==================== src/utils/logger.js ====================
const winston = require('winston');
const config = require('../config/env');

const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

winston.addColors(colors);

const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.colorize({ all: true }),
  winston.format.printf((info) => {
    const { timestamp, level, message, ...meta } = info;
    let msg = `${timestamp} [${level}]: ${message}`;
    if (Object.keys(meta).length > 0) {
      msg += ` ${JSON.stringify(meta)}`;
    }
    return msg;
  })
);

const transports = [
  new winston.transports.Console(),
  new winston.transports.File({
    filename: 'logs/error.log',
    level: 'error',
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
  new winston.transports.File({
    filename: 'logs/combined.log',
    maxsize: 5242880,
    maxFiles: 5,
  }),
];

const logger = winston.createLogger({
  level: config.log.level,
  levels,
  format,
  transports,
  exitOnError: false,
});

module.exports = logger;

// ==================== src/utils/ApiResponse.js ====================
class ApiResponse {
  constructor(statusCode, data, message = 'Success') {
    this.statusCode = statusCode;
    this.success = statusCode < 400;
    this.message = message;
    this.data = data;
    this.timestamp = new Date().toISOString();
  }

  static success(data, message = 'Success', statusCode = 200) {
    return new ApiResponse(statusCode, data, message);
  }

  static created(data, message = 'Resource created successfully') {
    return new ApiResponse(201, data, message);
  }

  static noContent(message = 'No content') {
    return new ApiResponse(204, null, message);
  }
}

module.exports = ApiResponse;

// ==================== src/utils/ApiError.js ====================
class ApiError extends Error {
  constructor(statusCode, message, isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  static badRequest(message = 'Bad Request') {
    return new ApiError(400, message);
  }

  static unauthorized(message = 'Unauthorized') {
    return new ApiError(401, message);
  }

  static forbidden(message = 'Forbidden') {
    return new ApiError(403, message);
  }

  static notFound(message = 'Resource not found') {
    return new ApiError(404, message);
  }

  static conflict(message = 'Conflict') {
    return new ApiError(409, message);
  }

  static tooManyRequests(message = 'Too many requests') {
    return new ApiError(429, message);
  }

  static internal(message = 'Internal server error') {
    return new ApiError(500, message, false);
  }
}

module.exports = ApiError;

// ==================== src/utils/asyncHandler.js ====================
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

module.exports = asyncHandler;

// ==================== src/utils/cache.js ====================
const redis = require('redis');
const config = require('../config/env');
const logger = require('./logger');

class CacheManager {
  constructor() {
    this.client = null;
    this.isConnected = false;
  }

  async connect() {
    try {
      this.client = redis.createClient({
        url: config.redis.url,
        socket: {
          reconnectStrategy: (retries) => {
            if (retries > 10) {
              logger.error('Redis max reconnection attempts reached');
              return new Error('Max reconnection attempts');
            }
            return Math.min(retries * 100, 3000);
          }
        }
      });

      this.client.on('error', (err) => logger.error('Redis Client Error', err));
      this.client.on('connect', () => logger.info('Redis connected'));
      this.client.on('disconnect', () => logger.warn('Redis disconnected'));

      await this.client.connect();
      this.isConnected = true;
    } catch (error) {
      logger.error('Redis connection failed:', error);
      this.isConnected = false;
    }
  }

  async get(key) {
    if (!this.isConnected) return null;
    try {
      const data = await this.client.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = 3600) {
    if (!this.isConnected) return false;
    try {
      await this.client.setEx(key, ttl, JSON.stringify(value));
      return true;
    } catch (error) {
      logger.error('Cache set error:', error);
      return false;
    }
  }

  async del(key) {
    if (!this.isConnected) return false;
    try {
      await this.client.del(key);
      return true;
    } catch (error) {
      logger.error('Cache delete error:', error);
      return false;
    }
  }

  async clear(pattern = '*') {
    if (!this.isConnected) return false;
    try {
      const keys = await this.client.keys(pattern);
      if (keys.length > 0) {
        await this.client.del(keys);
      }
      return true;
    } catch (error) {
      logger.error('Cache clear error:', error);
      return false;
    }
  }
}

module.exports = new CacheManager();

// ==================== src/middleware/error.middleware.js ====================
const ApiError = require('../utils/ApiError');
const logger = require('../utils/logger');
const config = require('../config/env');

const errorConverter = (err, req, res, next) => {
  let error = err;

  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Internal Server Error';
    error = new ApiError(statusCode, message, false, err.stack);
  }

  next(error);
};

const errorHandler = (err, req, res, next) => {
  let { statusCode, message } = err;

  if (config.env === 'production' && !err.isOperational) {
    statusCode = 500;
    message = 'Internal Server Error';
  }

  res.locals.errorMessage = message;

  const response = {
    statusCode,
    success: false,
    message,
    timestamp: new Date().toISOString(),
    ...(config.env === 'development' && { stack: err.stack }),
    ...(config.env === 'development' && { path: req.path }),
  };

  if (config.env === 'development') {
    logger.error(err);
  } else {
    logger.error(message, {
      statusCode,
      path: req.path,
      method: req.method,
      ip: req.ip,
    });
  }

  res.status(statusCode).json(response);
};

module.exports = { errorConverter, errorHandler };

// ==================== src/middleware/validation.middleware.js ====================
const { validationResult } = require('express-validator');
const ApiError = require('../utils/ApiError');

const validate = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(err => ({
      field: err.param,
      message: err.msg,
    }));
    
    throw ApiError.badRequest('Validation failed', { errors: errorMessages });
  }
  
  next();
};

module.exports = validate;

// ==================== src/middleware/rateLimit.middleware.js ====================
const rateLimit = require('express-rate-limit');
const config = require('../config/env');
const ApiError = require('../utils/ApiError');

const createRateLimiter = (options = {}) => {
  return rateLimit({
    windowMs: options.windowMs || config.rateLimit.windowMs,
    max: options.max || config.rateLimit.max,
    message: 'Too many requests from this IP, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res, next) => {
      throw ApiError.tooManyRequests('Too many requests, please try again later.');
    },
    ...options,
  });
};

const strictRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 5,
});

const authRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 20,
});

module.exports = {
  createRateLimiter,
  strictRateLimiter,
  authRateLimiter,
  defaultRateLimiter: createRateLimiter(),
};

// ==================== src/middleware/logger.middleware.js ====================
const morgan = require('morgan');
const logger = require('../utils/logger');
const config = require('../config/env');

morgan.token('message', (req, res) => res.locals.errorMessage || '');

const getIpFormat = () => (config.env === 'production' ? ':remote-addr - ' : '');
const successResponseFormat = `${getIpFormat()}:method :url :status - :response-time ms`;
const errorResponseFormat = `${getIpFormat()}:method :url :status - :response-time ms - message: :message`;

const successHandler = morgan(successResponseFormat, {
  skip: (req, res) => res.statusCode >= 400,
  stream: { write: (message) => logger.http(message.trim()) },
});

const errorHandler = morgan(errorResponseFormat, {
  skip: (req, res) => res.statusCode < 400,
  stream: { write: (message) => logger.error(message.trim()) },
});

module.exports = { successHandler, errorHandler };

// ==================== src/middleware/auth.middleware.js ====================
const jwt = require('jsonwebtoken');
const config = require('../config/env');
const ApiError = require('../utils/ApiError');
const asyncHandler = require('../utils/asyncHandler');

const authenticate = asyncHandler(async (req, res, next) => {
  const token = req.headers.authorization?.replace('Bearer ', '');

  if (!token) {
    throw ApiError.unauthorized('No token provided');
  }

  try {
    const decoded = jwt.verify(token, config.jwt.secret);
    req.user = decoded;
    next();
  } catch (error) {
    throw ApiError.unauthorized('Invalid or expired token');
  }
});

const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      throw ApiError.unauthorized('User not authenticated');
    }

    if (!roles.includes(req.user.role)) {
      throw ApiError.forbidden('Insufficient permissions');
    }

    next();
  };
};

module.exports = { authenticate, authorize };

// ==================== src/models/user.model.js ====================
const { DataTypes, Model } = require('sequelize');
const bcrypt = require('bcryptjs');

class User extends Model {
  async comparePassword(candidatePassword) {
    return await bcrypt.compare(candidatePassword, this.password);
  }

  toJSON() {
    const values = { ...this.get() };
    delete values.password;
    return values;
  }

  static initModel(sequelize) {
    User.init(
      {
        id: {
          type: DataTypes.INTEGER,
          primaryKey: true,
          autoIncrement: true,
        },
        name: {
          type: DataTypes.STRING(50),
          allowNull: false,
          validate: {
            notEmpty: { msg: 'Name is required' },
            len: {
              args: [1, 50],
              msg: 'Name cannot exceed 50 characters',
            },
          },
        },
        email: {
          type: DataTypes.STRING(100),
          allowNull: false,
          unique: {
            msg: 'Email already exists',
          },
          validate: {
            isEmail: { msg: 'Please provide a valid email' },
            notEmpty: { msg: 'Email is required' },
          },
          set(value) {
            this.setDataValue('email', value.toLowerCase().trim());
          },
        },
        password: {
          type: DataTypes.STRING(255),
          allowNull: false,
          validate: {
            notEmpty: { msg: 'Password is required' },
            len: {
              args: [8, 255],
              msg: 'Password must be at least 8 characters',
            },
          },
        },
        role: {
          type: DataTypes.ENUM('user', 'admin'),
          defaultValue: 'user',
          allowNull: false,
        },
        is_active: {
          type: DataTypes.BOOLEAN,
          defaultValue: true,
          allowNull: false,
        },
      },
      {
        sequelize,
        modelName: 'User',
        tableName: 'users',
        timestamps: true,
        underscored: true,
        indexes: [
          { fields: ['email'], unique: true },
          { fields: ['created_at'] },
        ],
        hooks: {
          beforeCreate: async (user) => {
            if (user.password) {
              user.password = await bcrypt.hash(user.password, 12);
            }
          },
          beforeUpdate: async (user) => {
            if (user.changed('password')) {
              user.password = await bcrypt.hash(user.password, 12);
            }
          },
        },
      }
    );

    return User;
  }
}

module.exports = User;

// ==================== src/models/invoice.model.js ====================
const { DataTypes, Model } = require('sequelize');

class Invoice extends Model {
    toJSON() {
        const values = { ...this.get() };
        return values;
    }

    static initModel(sequelize) {
        Invoice.init(
            {
                id: {
                    type: DataTypes.INTEGER,
                    primaryKey: true,
                    autoIncrement: true,
                },
                company_name: {
                    type: DataTypes.STRING(200),
                    allowNull: false,
                    validate: {
                        notEmpty: { msg: 'Company name is required' },
                    },
                },
                contact_person: {
                    type: DataTypes.STRING(100),
                    allowNull: false,
                    validate: {
                        notEmpty: { msg: 'Contact person is required' },
                    },
                },
                phone: {
                    type: DataTypes.STRING(20),
                    allowNull: false,
                    validate: {
                        notEmpty: { msg: 'Phone is required' },
                    },
                },
                email: {
                    type: DataTypes.STRING(100),
                    allowNull: false,
                    validate: {
                        isEmail: { msg: 'Please provide a valid email' },
                        notEmpty: { msg: 'Email is required' },
                    },
                },
                address: {
                    type: DataTypes.TEXT,
                    allowNull: false,
                },
                selected_plan_id: {
                    type: DataTypes.INTEGER,
                    allowNull: true,
                },
                platform_charge_type: {
                    type: DataTypes.STRING(50),
                    defaultValue: 'Monthly',
                },
                platform_charge: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                wallet_recharge: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                setup_fee: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                customization_fee: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                additional_fee: {
                    type: DataTypes.JSON,
                    defaultValue: [],
                },
                sub_total: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                discount_percent: {
                    type: DataTypes.DECIMAL(5, 2),
                    defaultValue: 0,
                },
                discount: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                amount_after_discount: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                gst: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                total: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                quotation_number: {
                    type: DataTypes.STRING(50),
                    allowNull: true,
                },
                quotation_date: {
                    type: DataTypes.DATEONLY,
                    allowNull: true,
                },
                quotation_valid_until_date: {
                    type: DataTypes.DATEONLY,
                    allowNull: true,
                },
                quotation_invoice_pdf_url: {
                    type: DataTypes.STRING(500),
                    allowNull: true,
                },
                proforma_invoice: {
                    type: DataTypes.BOOLEAN,
                    defaultValue: false,
                },
                proforma_number: {
                    type: DataTypes.STRING(50),
                    allowNull: true,
                },
                proforma_date: {
                    type: DataTypes.DATEONLY,
                    allowNull: true,
                },
                proforma_valid_until_date: {
                    type: DataTypes.DATEONLY,
                    allowNull: true,
                },
                payment_url: {
                    type: DataTypes.STRING(500),
                    allowNull: true,
                },
                proforma_invoice_pdf_url: {
                    type: DataTypes.STRING(500),
                    allowNull: true,
                },
                payment_receipt: {
                    type: DataTypes.BOOLEAN,
                    defaultValue: false,
                },
                payment_receipt_number: {
                    type: DataTypes.STRING(50),
                    allowNull: true,
                },
                payment_reference_number: {
                    type: DataTypes.STRING(100),
                    allowNull: true,
                },
                payment_receipt_date: {
                    type: DataTypes.DATEONLY,
                    allowNull: true,
                },
                payment_method: {
                    type: DataTypes.STRING(50),
                    allowNull: true,
                },
                payment_amount: {
                    type: DataTypes.DECIMAL(10, 2),
                    defaultValue: 0,
                },
                payment_invoice_pdf_url: {
                    type: DataTypes.STRING(500),
                    allowNull: true,
                },
            },
            {
                sequelize,
                modelName: 'Invoice',
                tableName: 'invoices',
                timestamps: true,
                underscored: true,
                indexes: [
                    { fields: ['quotation_number'] },
                    { fields: ['proforma_number'] },
                    { fields: ['payment_receipt_number'] },
                    { fields: ['email'] },
                    { fields: ['created_at'] },
                ],
            }
        );

        return Invoice;
    }
}

module.exports = Invoice;

// ==================== src/services/invoice.service.js ====================
const ApiError = require('../utils/ApiError');
const cache = require('../utils/cache');
const { Op } = require('sequelize');
const database = require('../config/database');

class InvoiceService {
    getInvoice() {
        return database.getModels().Invoice;
    }

    async createInvoice(invoiceData) {
        const Invoice = this.getInvoice();
        const invoice = await Invoice.create(invoiceData);
        return invoice;
    }

    async getInvoiceById(invoiceId) {
        const Invoice = this.getInvoice();
        const cacheKey = `invoice:${invoiceId}`;
        const cached = await cache.get(cacheKey);

        if (cached) return cached;

        const invoice = await Invoice.findByPk(invoiceId);

        if (!invoice) {
            throw ApiError.notFound('Invoice not found');
        }

        await cache.set(cacheKey, invoice, 600);
        return invoice;
    }

    async updateInvoice(invoiceId, updateData) {
        const Invoice = this.getInvoice();
        const invoice = await Invoice.findByPk(invoiceId);

        if (!invoice) {
            throw ApiError.notFound('Invoice not found');
        }

        await invoice.update(updateData);
        await cache.del(`invoice:${invoiceId}`);

        return invoice;
    }

    async deleteInvoice(invoiceId) {
        const Invoice = this.getInvoice();
        const invoice = await Invoice.findByPk(invoiceId);

        if (!invoice) {
            throw ApiError.notFound('Invoice not found');
        }

        await invoice.destroy();
        await cache.del(`invoice:${invoiceId}`);

        return invoice;
    }

    async getAllInvoices(query) {
        const Invoice = this.getInvoice();
        const { page = 1, limit = 10, sort = 'created_at', order = 'DESC', search } = query;

        const where = {};
        if (search) {
            where[Op.or] = [
                { company_name: { [Op.like]: `%${search}%` } },
                { contact_person: { [Op.like]: `%${search}%` } },
                { email: { [Op.like]: `%${search}%` } },
                { quotation_number: { [Op.like]: `%${search}%` } },
            ];
        }

        const offset = (page - 1) * limit;

        const { count, rows: invoices } = await Invoice.findAndCountAll({
            where,
            limit: parseInt(limit),
            offset: parseInt(offset),
            order: [[sort, order]],
        });

        return {
            invoices,
            totalPages: Math.ceil(count / limit),
            currentPage: parseInt(page),
            totalInvoices: count,
        };
    }
}

module.exports = new InvoiceService();

// ==================== src/controllers/invoice.controller.js ====================
const invoiceService = require('../services/invoice.service');
const ApiResponse = require('../utils/ApiResponse');
const asyncHandler = require('../utils/asyncHandler');
const fileUpload = require('../utils/fileUpload');

class InvoiceController {
    createInvoice = asyncHandler(async (req, res) => {
        const invoice = await invoiceService.createInvoice(req.body);
        res.status(201).json(ApiResponse.created(invoice, 'Invoice created successfully'));
    });

    createInvoiceWithPDF = asyncHandler(async (req, res) => {
        const { 
            quotation_pdf, 
            proforma_pdf, 
            payment_pdf,
            ...invoiceData 
        } = req.body;

        // Save PDFs if provided
        if (quotation_pdf) {
            const quotationFile = await fileUpload.saveBase64PDF(quotation_pdf, 'quotation');
            invoiceData.quotation_invoice_pdf_url = quotationFile.url;
        }

        if (proforma_pdf) {
            const proformaFile = await fileUpload.saveBase64PDF(proforma_pdf, 'proforma');
            invoiceData.proforma_invoice_pdf_url = proformaFile.url;
        }

        if (payment_pdf) {
            const paymentFile = await fileUpload.saveBase64PDF(payment_pdf, 'payment');
            invoiceData.payment_invoice_pdf_url = paymentFile.url;
        }

        const invoice = await invoiceService.createInvoice(invoiceData);
        res.status(201).json(ApiResponse.created(invoice, 'Invoice created successfully with PDFs'));
    });

    uploadInvoicePDF = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { pdf_data, pdf_type } = req.body;

        if (!pdf_data) {
            throw ApiError.badRequest('PDF data is required');
        }

        if (!['quotation', 'proforma', 'payment'].includes(pdf_type)) {
            throw ApiError.badRequest('Invalid PDF type. Must be quotation, proforma, or payment');
        }

        // Save PDF
        const file = await fileUpload.saveBase64PDF(pdf_data, pdf_type);

        // Update invoice with PDF URL
        const updateData = {};
        if (pdf_type === 'quotation') {
            updateData.quotation_invoice_pdf_url = file.url;
        } else if (pdf_type === 'proforma') {
            updateData.proforma_invoice_pdf_url = file.url;
        } else if (pdf_type === 'payment') {
            updateData.payment_invoice_pdf_url = file.url;
        }

        const invoice = await invoiceService.updateInvoice(id, updateData);

        res.json(ApiResponse.success({
            invoice,
            file: {
                url: file.url,
                filename: file.filename,
                size: file.size,
            }
        }, 'PDF uploaded successfully'));
    });

    getInvoice = asyncHandler(async (req, res) => {
        const invoice = await invoiceService.getInvoiceById(req.params.id);
        res.json(ApiResponse.success(invoice, 'Invoice retrieved successfully'));
    });

    updateInvoice = asyncHandler(async (req, res) => {
        const invoice = await invoiceService.updateInvoice(req.params.id, req.body);
        res.json(ApiResponse.success(invoice, 'Invoice updated successfully'));
    });

    deleteInvoice = asyncHandler(async (req, res) => {
        const invoice = await invoiceService.getInvoiceById(req.params.id);

        // Delete associated PDF files
        if (invoice.quotation_invoice_pdf_url) {
            await fileUpload.deleteFileByUrl(invoice.quotation_invoice_pdf_url);
        }
        if (invoice.proforma_invoice_pdf_url) {
            await fileUpload.deleteFileByUrl(invoice.proforma_invoice_pdf_url);
        }
        if (invoice.payment_invoice_pdf_url) {
            await fileUpload.deleteFileByUrl(invoice.payment_invoice_pdf_url);
        }

        await invoiceService.deleteInvoice(req.params.id);
        res.json(ApiResponse.success(null, 'Invoice and associated files deleted successfully'));
    });

    getAllInvoices = asyncHandler(async (req, res) => {
        const result = await invoiceService.getAllInvoices(req.query);
        res.json(ApiResponse.success(result, 'Invoices retrieved successfully'));
    });
}

module.exports = new InvoiceController();

// ==================== src/routes/invoice.routes.js ====================
const express = require('express');
const { body } = require('express-validator');
const invoiceController = require('../controllers/invoice.controller');
const { authenticate, authorize } = require('../middleware/auth.middleware');
const validate = require('../middleware/validation.middleware');

const router = express.Router();

const invoiceValidation = [
    body('company_name').trim().notEmpty().withMessage('Company name is required'),
    body('contact_person').trim().notEmpty().withMessage('Contact person is required'),
    body('phone').trim().notEmpty().withMessage('Phone is required'),
    body('email').isEmail().normalizeEmail().withMessage('Valid email is required'),
    body('address').trim().notEmpty().withMessage('Address is required'),
    validate,
];

const uploadPDFValidation = [
    body('pdf_data').notEmpty().withMessage('PDF data is required'),
    body('pdf_type').isIn(['quotation', 'proforma', 'payment']).withMessage('Invalid PDF type'),
    validate,
];

router.post('/', authenticate, invoiceValidation, invoiceController.createInvoice);
router.post('/with-pdf', authenticate, invoiceValidation, invoiceController.createInvoiceWithPDF);
router.post('/:id/upload-pdf', authenticate, uploadPDFValidation, invoiceController.uploadInvoicePDF);
router.get('/', authenticate, invoiceController.getAllInvoices);
router.get('/:id', authenticate, invoiceController.getInvoice);
router.put('/:id', authenticate, invoiceController.updateInvoice);
router.delete('/:id', authenticate, authorize('admin'), invoiceController.deleteInvoice);

module.exports = router;

// ==================== src/services/user.service.js ====================
const jwt = require('jsonwebtoken');
const config = require('../config/env');
const ApiError = require('../utils/ApiError');
const cache = require('../utils/cache');
const { Op } = require('sequelize');
const database = require('../config/database');

class UserService {
  getUser() {
    return database.getModels().User;
  }

  async createUser(userData) {
    const User = this.getUser();
    const existingUser = await User.findOne({ where: { email: userData.email } });
    
    if (existingUser) {
      throw ApiError.conflict('Email already registered');
    }

    const user = await User.create(userData);
    return user;
  }

  async loginUser(email, password) {
    const User = this.getUser();
    const user = await User.findOne({ 
      where: { email: email.toLowerCase() }
    });

    if (!user || !(await user.comparePassword(password))) {
      throw ApiError.unauthorized('Invalid email or password');
    }

    if (!user.is_active) {
      throw ApiError.forbidden('Account is deactivated');
    }

    const token = this.generateToken(user);
    
    return { user, token };
  }

  async getUserById(userId) {
    const User = this.getUser();
    const cacheKey = `user:${userId}`;
    const cached = await cache.get(cacheKey);
    
    if (cached) return cached;

    const user = await User.findByPk(userId);
    
    if (!user) {
      throw ApiError.notFound('User not found');
    }

    await cache.set(cacheKey, user, 600);
    return user;
  }

  async updateUser(userId, updateData) {
    const User = this.getUser();
    const user = await User.findByPk(userId);

    if (!user) {
      throw ApiError.notFound('User not found');
    }

    await user.update(updateData);
    await cache.del(`user:${userId}`);
    
    return user;
  }

  async deleteUser(userId) {
    const User = this.getUser();
    const user = await User.findByPk(userId);

    if (!user) {
      throw ApiError.notFound('User not found');
    }

    await user.destroy();
    await cache.del(`user:${userId}`);
    
    return user;
  }

  async getAllUsers(query) {
    const User = this.getUser();
    const { page = 1, limit = 10, sort = 'created_at', order = 'DESC', search } = query;
    
    const where = {};
    if (search) {
      where[Op.or] = [
        { name: { [Op.like]: `%${search}%` } },
        { email: { [Op.like]: `%${search}%` } },
      ];
    }

    const offset = (page - 1) * limit;

    const { count, rows: users } = await User.findAndCountAll({
      where,
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [[sort, order]],
    });

    return {
      users,
      totalPages: Math.ceil(count / limit),
      currentPage: parseInt(page),
      totalUsers: count,
    };
  }

  generateToken(user) {
    return jwt.sign(
      { id: user.id, email: user.email, role: user.role },
      config.jwt.secret,
      { expiresIn: config.jwt.expire }
    );
  }
}

module.exports = new UserService();

// ==================== src/controllers/user.controller.js ====================
const userService = require('../services/user.service');
const ApiResponse = require('../utils/ApiResponse');
const asyncHandler = require('../utils/asyncHandler');

class UserController {
  register = asyncHandler(async (req, res) => {
    const user = await userService.createUser(req.body);
    res.status(201).json(ApiResponse.created(user, 'User registered successfully'));
  });

  login = asyncHandler(async (req, res) => {
    const { email, password } = req.body;
    const result = await userService.loginUser(email, password);
    
    res.json(ApiResponse.success(result, 'Login successful'));
  });

  getProfile = asyncHandler(async (req, res) => {
    const user = await userService.getUserById(req.user.id);
    res.json(ApiResponse.success(user, 'Profile retrieved successfully'));
  });

  updateProfile = asyncHandler(async (req, res) => {
    const user = await userService.updateUser(req.user.id, req.body);
    res.json(ApiResponse.success(user, 'Profile updated successfully'));
  });

  deleteUser = asyncHandler(async (req, res) => {
    await userService.deleteUser(req.params.id);
    res.json(ApiResponse.success(null, 'User deleted successfully'));
  });

  getAllUsers = asyncHandler(async (req, res) => {
    const result = await userService.getAllUsers(req.query);
    res.json(ApiResponse.success(result, 'Users retrieved successfully'));
  });
}

module.exports = new UserController();

// ==================== src/routes/user.routes.js ====================
const express = require('express');
const { body } = require('express-validator');
const userController = require('../controllers/user.controller');
const { authenticate, authorize } = require('../middleware/auth.middleware');
const validate = require('../middleware/validation.middleware');
const { authRateLimiter } = require('../middleware/rateLimit.middleware');

const router = express.Router();

const registerValidation = [
  body('name').trim().notEmpty().withMessage('Name is required'),
  body('email').isEmail().normalizeEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters'),
  validate,
];

const loginValidation = [
  body('email').isEmail().normalizeEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
  validate,
];

router.post('/register', authRateLimiter, registerValidation, userController.register);
router.post('/login', authRateLimiter, loginValidation, userController.login);
router.get('/profile', authenticate, userController.getProfile);
router.patch('/profile', authenticate, userController.updateProfile);
router.get('/', authenticate, authorize('admin'), userController.getAllUsers);
router.delete('/:id', authenticate, authorize('admin'), userController.deleteUser);

module.exports = router;

// ==================== src/routes/index.js ====================
const express = require('express');
const userRoutes = require('./user.routes');

const router = express.Router();

const defaultRoutes = [
  {
    path: '/users',
    route: userRoutes,
  },
  {
    path: '/invoices',
    route: require('./invoice.routes'),
  },
];

defaultRoutes.forEach((route) => {
  router.use(route.path, route.route);
});

router.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

module.exports = router;

// ==================== src/app.js ====================
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const compression = require('compression');
const mongoSanitize = require('express-mongo-sanitize');
const config = require('./config/env');
const routes = require('./routes');
const { errorConverter, errorHandler } = require('./middleware/error.middleware');
const { successHandler, errorHandler: logErrorHandler } = require('./middleware/logger.middleware');
const { defaultRateLimiter } = require('./middleware/rateLimit.middleware');
const ApiError = require('./utils/ApiError');

const app = express();

// Security middleware
app.use(helmet());
app.use(cors());

// Request parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Compression
app.use(compression());

// Logging
if (config.env !== 'test') {
  app.use(successHandler);
  app.use(logErrorHandler);
}

// Rate limiting
app.use(defaultRateLimiter);

// Trust proxy
app.set('trust proxy', 1);

// API routes
app.use('/api/v1', routes);

// 404 handler
app.use((req, res, next) => {
  next(ApiError.notFound('Route not found'));
});

// Error handling
app.use(errorConverter);
app.use(errorHandler);

module.exports = app;

// ==================== server.js ====================
const app = require('./src/app');
const config = require('./src/config/env');
const database = require('./src/config/database');
const cache = require('./src/utils/cache');
const logger = require('./src/utils/logger');

let server;

async function startServer() {
  try {
    // Connect to database
    await database.connect();

    // Connect to cache
    await cache.connect();

    // Start server
    server = app.listen(config.port, () => {
      logger.info(`Server running on port ${config.port} in ${config.env} mode`);
    });

    // Graceful shutdown
    const gracefulShutdown = async (signal) => {
      logger.info(`${signal} received, shutting down gracefully...`);
      
      server.close(async () => {
        logger.info('HTTP server closed');
        await database.disconnect();
        process.exit(0);
      });

      setTimeout(() => {
        logger.error('Forced shutdown after timeout');
        process.exit(1);
      }, 10000);
    };

    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  logger.error('Unhandled Rejection:', err);
  if (server) {
    server.close(() => process.exit(1));
  } else {
    process.exit(1);
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  logger.error('Uncaught Exception:', err);
  process.exit(1);
});